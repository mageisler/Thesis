\chapter{Obtaining Signal Particles \label{sec:OSP} }

Many of the following event objects like jets or missing transverse energy are build on all reconstructed particles that are considered as signal. Since the work flow presented in Chapter~\ref{sec:AssMap} can only be applied on charged particles that leave a track in the tracker, another technique needs to be applied for neutral particles. Based on the associations for both particles, charged and neutral, a new particle collection can be created containing only those that are associated to the first primary vertex.

\section{From Tracks to Particles \label{sec:OSPT2P}}

For neutral particles like photons a track reconstruction is not possible. They are reconstructed by their energy signature in the calorimeters. Since the resolution of the calorimeter for the direction of the incoming particle is rather poor compared to the tracker, an individual association cannot be done for neutral particles. Therefore, all reconstructed neutral particles are associated to the first vertex. If the number of associations is set to more than one, the particle is associated in each iteration to the respective first primary vertex of the collection. The first primary vertex is removed from the collection after an iteration, too. \\
A loop is carried out on a given collection of reconstructed particles. First, it is checked if the particle is charged and is reconstructed in the tracker. If so, the procedure presented in Section~\ref{sec:AMWorkflow} is executed. If not, the particle is always associated to the first vertex. The quality of this association is then defined as the negative value of the iteration at which it is created.  This has the advantage that one can easily differ between neutral particles and charged particles that have positive values for the quality. In doing so another association map is produced. Both types of association, particles to vertices or vertices to particles, can be created, too.

\section{First Vertex Candidates \label{sec:OSPFVC}}

In order to obtain only those particles that are considered as coming from the first vertex the produced association map is taken as an input. If the way of association is particles to vertices then it is very easy to obtain the signal particles since the vertices are sorted by decreasing sum of \pt in the map (see Section~\ref{sec:LHCCMSPaVR}). If vertices are associated to particles the initial vertex collection needs to be given, too. Then the first vertex from this collection is taken and for every particle it is checked if they are associated to this primary vertex. A cut on the quality of the association can also be set. All particles that are associated to the first vertex and pass the quality filter are then put into a new particle collection. Based on this collection jets can be produced or the missing transverse energy can be calculated, for instance.

\section{Memory and Time Consumption \label{sec:OSPMemTime}}
Finally, the computing time and memory consumption of this approach should be compared to the existing techniques described in Section~\ref{sec:IntroCurPST}. \\
For the association map, only the two producers presented in Chapters~\ref{sec:AssMap} and~\ref{sec:OSPFVC} need to be executed. For the Jet/MET and Muon/Egamma approach the different filter for charged hadrons, muons and electrons are executed. Furthermore, for each of these filters two collections are produced, one for those particles that are considered as pileup and another collection including all particles but not those from the pileup collection. Therefore, more but also faster modules are run in this sequence compared to the association map. \\
The studies are done for three different simulated samples. One with $\Zz\rightarrow\EE$ decays with a rather small amount of tracks, another one with \Zz decays to \MM with one additional jet from the initial state and \ttbar events with a rather high track multiplicity. For all samples the number of underlying pileup interactions is about 20. \\

\input{TimeMemoryTableZMM}
\input{TimeMemoryTableZEE}
\clearpage{}

The time consumption is analyzed as follows. For each module the time per execution is taken. For each approach for all modules these times are summed up. There are two different time definitions. One for the real time and one for the CPU time. The latter one will be always the same or smaller than the real time depending on the input and output involvement or other resources. The resulting values can be found in Tables~\ref{tab:OSPTimMemZMM} to~\ref{tab:OSPTimMemTT}. It can be seen that the association map needs much more time. Although only two modules are run compared to about eight at the other approaches. This is due to the customized association procedure that takes much more time than just a filter based on one or two values. The creation of the association map alone takes about $99\,\%$ of the listed time. \\
The used memory is calculated similar to the time consumption. For each module the averaged value for one event is taken. For each approach these values are then summed up. Again two different memory consumptions are calculated. One for the uncompressed and one for the compressed size. During the processing of a single event all outputs from the modules are stored uncompressed temporary at the working storage. At the end only the needed outputs are written compressed into the output file. Comparing the results from Tables~\ref{tab:OSPTimMemZMM} to~\ref{tab:OSPTimMemTT} it can be seen that the total size of all outputs from the association map is always a lot smaller compared to the other ones. Furthermore, it needs to be mentioned that the association map itself needs only $20\,\%$ of the memory of the created track collection. The reason is that in the association map the tracks as well as the vertices are stored as references to members of a collection. On the other hand within a track collection always the full information is stored. Since the other approaches create several temporary track collections their memory consumption is comparably large. Hence, much memory is saved using the association map.

\input{TimeMemoryTableTT}